// Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

export const typeDefs = /* GraphQL */ `type AggregateArtist {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type AggregateVinyl {
  count: Int!
}

type Artist {
  id: ID!
  name: String!
  vinyls(where: VinylWhereInput, orderBy: VinylOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Vinyl!]
}

type ArtistConnection {
  pageInfo: PageInfo!
  edges: [ArtistEdge]!
  aggregate: AggregateArtist!
}

input ArtistCreateInput {
  id: ID
  name: String!
  vinyls: VinylCreateManyWithoutArtistsInput
}

input ArtistCreateManyWithoutVinylsInput {
  create: [ArtistCreateWithoutVinylsInput!]
  connect: [ArtistWhereUniqueInput!]
}

input ArtistCreateWithoutVinylsInput {
  id: ID
  name: String!
}

type ArtistEdge {
  node: Artist!
  cursor: String!
}

enum ArtistOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
}

type ArtistPreviousValues {
  id: ID!
  name: String!
}

input ArtistScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  AND: [ArtistScalarWhereInput!]
  OR: [ArtistScalarWhereInput!]
  NOT: [ArtistScalarWhereInput!]
}

type ArtistSubscriptionPayload {
  mutation: MutationType!
  node: Artist
  updatedFields: [String!]
  previousValues: ArtistPreviousValues
}

input ArtistSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ArtistWhereInput
  AND: [ArtistSubscriptionWhereInput!]
  OR: [ArtistSubscriptionWhereInput!]
  NOT: [ArtistSubscriptionWhereInput!]
}

input ArtistUpdateInput {
  name: String
  vinyls: VinylUpdateManyWithoutArtistsInput
}

input ArtistUpdateManyDataInput {
  name: String
}

input ArtistUpdateManyMutationInput {
  name: String
}

input ArtistUpdateManyWithoutVinylsInput {
  create: [ArtistCreateWithoutVinylsInput!]
  delete: [ArtistWhereUniqueInput!]
  connect: [ArtistWhereUniqueInput!]
  set: [ArtistWhereUniqueInput!]
  disconnect: [ArtistWhereUniqueInput!]
  update: [ArtistUpdateWithWhereUniqueWithoutVinylsInput!]
  upsert: [ArtistUpsertWithWhereUniqueWithoutVinylsInput!]
  deleteMany: [ArtistScalarWhereInput!]
  updateMany: [ArtistUpdateManyWithWhereNestedInput!]
}

input ArtistUpdateManyWithWhereNestedInput {
  where: ArtistScalarWhereInput!
  data: ArtistUpdateManyDataInput!
}

input ArtistUpdateWithoutVinylsDataInput {
  name: String
}

input ArtistUpdateWithWhereUniqueWithoutVinylsInput {
  where: ArtistWhereUniqueInput!
  data: ArtistUpdateWithoutVinylsDataInput!
}

input ArtistUpsertWithWhereUniqueWithoutVinylsInput {
  where: ArtistWhereUniqueInput!
  update: ArtistUpdateWithoutVinylsDataInput!
  create: ArtistCreateWithoutVinylsInput!
}

input ArtistWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  vinyls_every: VinylWhereInput
  vinyls_some: VinylWhereInput
  vinyls_none: VinylWhereInput
  AND: [ArtistWhereInput!]
  OR: [ArtistWhereInput!]
  NOT: [ArtistWhereInput!]
}

input ArtistWhereUniqueInput {
  id: ID
}

type BatchPayload {
  count: Long!
}

scalar Long

type Mutation {
  createArtist(data: ArtistCreateInput!): Artist!
  updateArtist(data: ArtistUpdateInput!, where: ArtistWhereUniqueInput!): Artist
  updateManyArtists(data: ArtistUpdateManyMutationInput!, where: ArtistWhereInput): BatchPayload!
  upsertArtist(where: ArtistWhereUniqueInput!, create: ArtistCreateInput!, update: ArtistUpdateInput!): Artist!
  deleteArtist(where: ArtistWhereUniqueInput!): Artist
  deleteManyArtists(where: ArtistWhereInput): BatchPayload!
  createUser(data: UserCreateInput!): User!
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateManyUsers(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!
  deleteUser(where: UserWhereUniqueInput!): User
  deleteManyUsers(where: UserWhereInput): BatchPayload!
  createVinyl(data: VinylCreateInput!): Vinyl!
  updateVinyl(data: VinylUpdateInput!, where: VinylWhereUniqueInput!): Vinyl
  updateManyVinyls(data: VinylUpdateManyMutationInput!, where: VinylWhereInput): BatchPayload!
  upsertVinyl(where: VinylWhereUniqueInput!, create: VinylCreateInput!, update: VinylUpdateInput!): Vinyl!
  deleteVinyl(where: VinylWhereUniqueInput!): Vinyl
  deleteManyVinyls(where: VinylWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Query {
  artist(where: ArtistWhereUniqueInput!): Artist
  artists(where: ArtistWhereInput, orderBy: ArtistOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Artist]!
  artistsConnection(where: ArtistWhereInput, orderBy: ArtistOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ArtistConnection!
  user(where: UserWhereUniqueInput!): User
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!
  usersConnection(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserConnection!
  vinyl(where: VinylWhereUniqueInput!): Vinyl
  vinyls(where: VinylWhereInput, orderBy: VinylOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Vinyl]!
  vinylsConnection(where: VinylWhereInput, orderBy: VinylOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): VinylConnection!
  node(id: ID!): Node
}

type Subscription {
  artist(where: ArtistSubscriptionWhereInput): ArtistSubscriptionPayload
  user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
  vinyl(where: VinylSubscriptionWhereInput): VinylSubscriptionPayload
}

type User {
  id: ID!
  name: String!
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge]!
  aggregate: AggregateUser!
}

input UserCreateInput {
  id: ID
  name: String!
}

type UserEdge {
  node: User!
  cursor: String!
}

enum UserOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
}

type UserPreviousValues {
  id: ID!
  name: String!
}

type UserSubscriptionPayload {
  mutation: MutationType!
  node: User
  updatedFields: [String!]
  previousValues: UserPreviousValues
}

input UserSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserWhereInput
  AND: [UserSubscriptionWhereInput!]
  OR: [UserSubscriptionWhereInput!]
  NOT: [UserSubscriptionWhereInput!]
}

input UserUpdateInput {
  name: String
}

input UserUpdateManyMutationInput {
  name: String
}

input UserWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
}

input UserWhereUniqueInput {
  id: ID
}

type Vinyl {
  id: ID!
  name: String!
  artists(where: ArtistWhereInput, orderBy: ArtistOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Artist!]
}

type VinylConnection {
  pageInfo: PageInfo!
  edges: [VinylEdge]!
  aggregate: AggregateVinyl!
}

input VinylCreateInput {
  id: ID
  name: String!
  artists: ArtistCreateManyWithoutVinylsInput
}

input VinylCreateManyWithoutArtistsInput {
  create: [VinylCreateWithoutArtistsInput!]
  connect: [VinylWhereUniqueInput!]
}

input VinylCreateWithoutArtistsInput {
  id: ID
  name: String!
}

type VinylEdge {
  node: Vinyl!
  cursor: String!
}

enum VinylOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
}

type VinylPreviousValues {
  id: ID!
  name: String!
}

input VinylScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  AND: [VinylScalarWhereInput!]
  OR: [VinylScalarWhereInput!]
  NOT: [VinylScalarWhereInput!]
}

type VinylSubscriptionPayload {
  mutation: MutationType!
  node: Vinyl
  updatedFields: [String!]
  previousValues: VinylPreviousValues
}

input VinylSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: VinylWhereInput
  AND: [VinylSubscriptionWhereInput!]
  OR: [VinylSubscriptionWhereInput!]
  NOT: [VinylSubscriptionWhereInput!]
}

input VinylUpdateInput {
  name: String
  artists: ArtistUpdateManyWithoutVinylsInput
}

input VinylUpdateManyDataInput {
  name: String
}

input VinylUpdateManyMutationInput {
  name: String
}

input VinylUpdateManyWithoutArtistsInput {
  create: [VinylCreateWithoutArtistsInput!]
  delete: [VinylWhereUniqueInput!]
  connect: [VinylWhereUniqueInput!]
  set: [VinylWhereUniqueInput!]
  disconnect: [VinylWhereUniqueInput!]
  update: [VinylUpdateWithWhereUniqueWithoutArtistsInput!]
  upsert: [VinylUpsertWithWhereUniqueWithoutArtistsInput!]
  deleteMany: [VinylScalarWhereInput!]
  updateMany: [VinylUpdateManyWithWhereNestedInput!]
}

input VinylUpdateManyWithWhereNestedInput {
  where: VinylScalarWhereInput!
  data: VinylUpdateManyDataInput!
}

input VinylUpdateWithoutArtistsDataInput {
  name: String
}

input VinylUpdateWithWhereUniqueWithoutArtistsInput {
  where: VinylWhereUniqueInput!
  data: VinylUpdateWithoutArtistsDataInput!
}

input VinylUpsertWithWhereUniqueWithoutArtistsInput {
  where: VinylWhereUniqueInput!
  update: VinylUpdateWithoutArtistsDataInput!
  create: VinylCreateWithoutArtistsInput!
}

input VinylWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  artists_every: ArtistWhereInput
  artists_some: ArtistWhereInput
  artists_none: ArtistWhereInput
  AND: [VinylWhereInput!]
  OR: [VinylWhereInput!]
  NOT: [VinylWhereInput!]
}

input VinylWhereUniqueInput {
  id: ID
}
`